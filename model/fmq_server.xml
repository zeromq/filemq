<class name = "fmq_server" script = "server_c" codec = "fmq_msg">
FileMQ protocol server
<include filename = "license.xml" />

<state name = "start">
    <event name = "OHAI" next = "checking client">
        <action name = "track client identity" />
        <action name = "try anonymous access" />
    </event>
</state>

<state name = "checking client">
    <event name = "friend" next = "ready">
        <action name = "send" message ="OHAI-OK" />
    </event>
    <event name = "foe">
        <action name = "send" message = "SRSLY" />
        <action name = "terminate the client" />
    </event>
    <event name = "maybe" next = "challenging client">
        <action name = "list security mechanisms" />
        <action name = "send" message = "ORLY" />
    </event>
</state>

<state name = "challenging client">
    <event name = "YARLY" next = "checking client">
        <action name = "try security mechanism" />
    </event>
</state>

<state name = "ready">
    <event name = "ICANHAZ">
        <action name = "store client subscription" />
        <action name = "send" message = "ICANHAZ-OK" />
    </event>
    <event name = "NOM" next = "dispatching">
        <action name = "store client credit" />
        <action name = "get next patch for client" />
    </event>
    <event name = "HUGZ">
        <action name = "send" message = "HUGZ-OK" />
    </event>
    <event name = "KTHXBAI">
        <action name = "terminate the client" />
    </event>
    <event name = "dispatch" next = "dispatching">
        <action name = "get next patch for client" />
    </event>
    <event name = "heartbeat">
        <action name = "send" message = "HUGZ" />
    </event>
</state>

<state name = "dispatching">
    <event name = "send chunk">
        <action name = "send" message = "CHEEZBURGER" />
        <action name = "get next patch for client" />
    </event>
    <event name = "send delete">
        <action name = "send" message = "CHEEZBURGER" />
        <action name = "get next patch for client" />
    </event>
    <event name = "next patch">
        <action name = "get next patch for client" />
    </event>
    <event name = "no credit" next = "ready" />
    <event name = "finished" next = "ready" />
</state>

<state name = "defaults">
    <event name = "heartbeat" />
    <event name = "expired">
        <action name = "terminate the client" />
    </event>
    <!-- Client can restart connection at any time -->
    <event name = "OHAI" next = "checking client">
        <action name = "track client identity" />
        <action name = "try anonymous access" />
    </event>
    <event name = "$other">
        <action name = "send" message = "RTFM" />
        <action name = "terminate the client" />
    </event>
</state>

<!-- Server and client contexts -->
<declare>
//  There's no point making these configurable
#define CHUNK_SIZE      1000000
</declare>


<self>
<context>
zlist_t *mounts;            //  Mount points
</context>

<construct>
self->mounts = zlist_new ();
</construct>

<destruct>
//  Destroy mount points
while (zlist_size (self->mounts)) {
    mount_t *mount = (mount_t *) zlist_pop (self->mounts);
    mount_destroy (&mount);
}
zlist_destroy (&self->mounts);
</destruct>
</self>


<client>
<context>
byte identity [FMQ_MSG_IDENTITY_SIZE];
size_t credit;              //  Credit remaining
zlist_t *patches;           //  Patches to send
fmq_patch_t *patch;         //  Current patch
fmq_file_t *file;           //  Current file we're sending
off_t offset;               //  Offset of next read in file
int64_t sequence;           //  Sequence number for chunk
</context>

<construct>
self->patches = zlist_new ();
</construct>

<destruct>
while (zlist_size (self->patches)) {
    fmq_patch_t *patch = (fmq_patch_t *) zlist_pop (self->patches);
    fmq_patch_destroy (&patch);
}
zlist_destroy (&self->patches);
</destruct>
</client>

<!-- Embedded class for subscriptions -->
<include filename = "fmq_server_sub.xml" />
<!-- Embedded class for mount points -->
<include filename = "fmq_server_mount.xml" />

<!-- Action bodies -->
<action name = "terminate the client">
mount_t *mount = (mount_t *) zlist_first (self->mounts);
while (mount) {
    mount_sub_purge (mount, client);
    mount = (mount_t *) zlist_next (self->mounts);
}
client->next_event = terminate_event;
</action>

<action name = "track client identity">
memcpy (client->identity, fmq_msg_identity (client->request), FMQ_MSG_IDENTITY_SIZE);
</action>

<action name = "try anonymous access">
if (atoi (fmq_config_resolve (self->config, "security/anonymous", "0")) == 1)
    client->next_event = friend_event;
else
if (atoi (fmq_config_resolve (self->config, "security/plain", "0")) == 1)
    client->next_event = maybe_event;
else
    client->next_event = foe_event;
</action>
    
<action name = "list security mechanisms">
if (atoi (fmq_config_resolve (self->config, "security/anonymous", "0")) == 1)
    fmq_msg_mechanisms_append (client->reply, "ANONYMOUS");
if (atoi (fmq_config_resolve (self->config, "security/plain", "0")) == 1)
    fmq_msg_mechanisms_append (client->reply, "PLAIN");
</action>

<action name = "try security mechanism">
client->next_event = foe_event;
char *login, *password;
if (streq (fmq_msg_mechanism (client->request), "PLAIN")
&&  fmq_sasl_plain_decode (fmq_msg_response (client->request), &login, &password) == 0) {
    fmq_config_t *account = fmq_config_locate (self->config, "security/plain/account");
    while (account) {
        if (streq (fmq_config_resolve (account, "login", ""), login)
        &&  streq (fmq_config_resolve (account, "password", ""), password)) {
            client->next_event = friend_event;
            break;
        }
        account = fmq_config_next (account);
    }
}
free (login);
free (password);
</action>

<action name = "store client subscription">
//  Find mount point with longest match to subscription
char *path = fmq_msg_path (client->request);
mount_t *mount = (mount_t *) zlist_first (self->mounts);
mount_t *match = mount;
while (mount) {
    //  If mount->alias is prefix of path and alias is
    //  longer than previous best then we have a new best
    if (strncmp (path, mount->alias, strlen (mount->alias)) == 0
    &&  strlen (mount->alias) > strlen (match->alias))
        match = mount;
    mount = (mount_t *) zlist_next (self->mounts);
}
mount_sub_store (match, client, path);
</action>

<action name = "store client credit">
client->credit += fmq_msg_credit (client->request);
</action>

<!-- Hook actions -->
<declare>
//  Client hash function that checks if client is alive
static int
client_dispatch (const char *key, void *client, void *server)
{
    server_client_execute ((server_t *) server, (client_t *) client, dispatch_event);
    return 0;
}
</declare>

<action name = "monitor the server">
bool activity = false;
mount_t *mount = (mount_t *) zlist_first (self->mounts);
while (mount) {
    if (mount_refresh (mount, self))
        activity = true;
    mount = (mount_t *) zlist_next (self->mounts);
}
if (activity)
    zhash_foreach (self->clients, client_dispatch, self);
</action>

<action name = "get next patch for client">
//  Get next patch for client if we're not doing one already
if (client->patch == NULL)
    client->patch = (fmq_patch_t *) zlist_pop (client->patches);
if (client->patch == NULL) {
    client->next_event = finished_event;
    return;
}
//  Map filename to logical space
char *filename = fmq_file_name (fmq_patch_file (client->patch), fmq_patch_path (client->patch));

printf ("MAP FILE: \nroot=%s\nname=%s\nresult=%s\n",
    fmq_patch_path (client->patch),
    fmq_file_name (fmq_patch_file (client->patch), NULL),
    filename);
    
fmq_msg_filename_set (client->reply, filename);

//  We can process a delete patch right away
if (fmq_patch_op (client->patch) == patch_delete) {
    fmq_msg_sequence_set (client->reply, client->sequence++);
    fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_DELETE);
    client->next_event = send_delete_event;
    
    //  No reliability in this version, assume patch delivered safely
    fmq_patch_destroy (&client->patch);
}
else {
    //  Create patch refers to file, open that for input if needed
    if (client->file == NULL) {
        client->file = fmq_file_dup (fmq_patch_file (client->patch));
        if (fmq_file_input (client->file)) {
            //  File no longer available, skip it
            fmq_patch_destroy (&client->patch);
            fmq_file_destroy (&client->file);
            client->next_event = next_patch_event;
            return;
        }
        client->offset = 0;
    }
    //  Get next chunk for file
    fmq_chunk_t *chunk = fmq_file_read (client->file, CHUNK_SIZE, client->offset);
    assert (chunk);

    //  Check if we have the credit to send chunk
    if (fmq_chunk_size (chunk) <= client->credit) {
        fmq_msg_sequence_set (client->reply, client->sequence++);
        fmq_msg_operation_set (client->reply, FMQ_MSG_FILE_CREATE);
        fmq_msg_offset_set (client->reply, client->offset);
        fmq_msg_chunk_set (client->reply, zframe_new (
            fmq_chunk_data (chunk),
            fmq_chunk_size (chunk)));
        
        client->offset += fmq_chunk_size (chunk);
        client->credit -= fmq_chunk_size (chunk);
        client->next_event = send_chunk_event;
        
        //  Zero-sized chunk means end of file
        if (fmq_chunk_size (chunk) == 0) {
            fmq_file_destroy (&client->file);
            fmq_patch_destroy (&client->patch);
        }
    }
    else
        client->next_event = no_credit_event;
        
    fmq_chunk_destroy (&chunk);
}
</action>

<!-- API methods -->

<method name = "bind">
<argument name = "endpoint" type = "string" />
zmq_bind (self->router, endpoint);
</method>

<method name = "publish">
<argument name = "location" type = "string" />
<argument name = "alias" type = "string" />
mount_t *mount = mount_new (location, alias);
zlist_append (self->mounts, mount);
</method>

<method name = "set anonymous">
<argument name = "access" type = "number" />
//  Enable anonymous access without a config file
fmq_config_path_set (self->config, "security/anonymous", access? "1" :"0");
</method>

<include filename = "fmq_server_selftest.xml" />

</class>
